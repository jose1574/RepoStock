<!-- Chequeo de Recepción de Traslados: igual a chequeo de orden pero usando TRANSFER procesadas (wait=false) -->

{% extends "base.html" %}

{% block content %}
<div class="mx-auto px-4 py-6">
  <h1 class="text-xl font-semibold mb-4">Chequeo de Recepción de Traslados</h1>
  <style>
    /* Resaltado fuerte reutilizado del chequeo de recolección */
    .collection-highlight {
      background-color: #fff7ed; /* naranja muy claro */
      box-shadow: inset 0 0 0 9999px rgba(255, 186, 73, 0.15);
      outline: 2px solid #f59e0b;
    }
    .collection-highlight td { transition: background-color .15s ease; }
    /* Responsive: convertir tabla a tarjetas en móviles */
    @media (max-width: 640px) {
      .reception-table thead { display: none; }
      .reception-table tbody tr {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        padding: 0.6rem 0.75rem 0.7rem 0.75rem;
        border: 1px solid #e5e7eb;
        border-radius: 0.5rem;
        background: #ffffff;
        margin-bottom: 0.5rem;
      }
      .reception-table tbody tr td {
        display: flex;
        align-items: flex-start;
        font-size: 0.72rem;
        padding: 0.15rem 0.25rem;
        border: 0;
      }
      .reception-table tbody tr td::before {
        content: attr(data-label);
        font-weight: 600;
        color: #374151;
        width: 6.5rem;
        flex: 0 0 6.5rem;
        text-align: left;
        padding-right: 0.35rem;
        line-height: 1.05rem;
      }
      .reception-table tbody tr td.desc-cell {
        flex-direction: column;
      }
      .reception-table tbody tr td.desc-cell::before {
        width: auto;
        flex: 0 0 auto;
        margin-bottom: 0.15rem;
      }
      .reception-table tbody tr td.desc-cell span, .reception-table tbody tr td.desc-cell { line-height: 1.05rem; }
      .reception-table tbody tr td.status-cell::before { width: 6.5rem; }
      .reception-actions { flex-direction: column; align-items: stretch; }
      .reception-actions > div, .reception-actions button { width: 100%; }
      .reception-actions input { width: 100% !important; }
    }
    @media (min-width: 640px) and (max-width: 880px) {
      .reception-table thead th, .reception-table tbody td { padding: 0.35rem 0.5rem; }
      .reception-table tbody td { font-size: 0.75rem; }
    }
  </style>

  <form method="get" class="mb-6 flex items-end gap-3 {{ 'hidden' if correlative and header else '' }}">
    <div>
      <label for="correlative" class="block text-sm font-medium text-gray-700">Correlativo de TRANSFER procesada</label>
      <input type="number" name="correlative" id="correlative" required class="border rounded px-3 py-2 w-48" placeholder="Ej: 1234" value="{{ correlative if correlative else '' }}">
    </div>
    <button type="submit" class="px-4 py-2 bg-indigo-600 text-white rounded">Cargar</button>
  </form>

  <div id="check-meta" data-correlative="{{ correlative if correlative else '' }}" data-not-found="{{ '1' if correlative and not header and not pending_wait else '0' }}" data-pending="{{ '1' if pending_wait else '0' }}"></div>

  {% if correlative and header %}
  <div class="mb-4 text-sm text-gray-600 space-y-1">
    <p><span class="font-medium">Correlativo:</span> {{ correlative }}</p>
    <p><span class="font-medium">Depósito origen:</span> {{ header.store }}</p>
    <p><span class="font-medium">Depósito destino:</span> {{ header.destination_store }}</p>
    <p><span class="font-medium">Fecha emisión:</span> {{ header.emission_date }}</p>
    <p class="text-xs text-gray-500">TRANSFER procesada (recepción sin chequear)</p>
  </div>

  <div class="flex flex-wrap items-center gap-3 mb-4 reception-actions">
    <div>
      <label for="product-search" class="text-sm font-medium text-gray-700">Buscar código de barra</label>
      <input id="product-search" type="text" placeholder="pistolear codigo de barra" class="border rounded px-2 py-1 text-sm w-48"
             inputmode="none" autocomplete="off" autocorrect="off" spellcheck="false" enterkeyhint="done" />
    </div>
    <div>
      <label for="manual-code" class="text-sm font-medium text-gray-700">Código manual</label>
      <input id="manual-code" type="text" placeholder="Ingresar código manualmente" class="border rounded px-2 py-1 text-sm w-48"
             autocomplete="off" autocapitalize="none" spellcheck="false" />
    </div>
    <div>
      <label for="counted-qty" class="text-sm font-medium text-gray-700">Cantidad contada</label>
      <input id="counted-qty" type="number" step="any" min="0" class="border rounded px-2 py-1 text-sm w-32" />
    </div>
    <button id="apply-count" type="button" class="px-3 py-1 bg-green-600 text-white rounded">Aplicar conteo</button>
    <button id="finalize-reception" type="button" class="px-3 py-1 bg-blue-600 text-white rounded">Validar recepción</button>
    <span id="status-msg" class="text-sm text-gray-700"></span>
  </div>

  <div class="overflow-x-auto overflow-y-auto max-h-[60vh] border rounded">
    <table class="min-w-full divide-y divide-gray-200 reception-table">
      <thead class="bg-gray-50">
        <tr>
          <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase">Código</th>
          <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase">Descripción</th>
          <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase">Unidad</th>
          <th class="px-3 py-2 text-right text-xs font-medium text-gray-500 uppercase">Cant. Orden</th>
          <th class="px-3 py-2 text-right text-xs font-medium text-gray-500 uppercase">Cant. Contada</th>
          <th class="px-3 py-2 text-right text-xs font-medium text-gray-500 uppercase">Estado</th>
        </tr>
      </thead>
      <tbody id="collection-items" class="bg-white divide-y divide-gray-200 text-sm">
        {% for item in items %}
        <tr data-code="{{ item.code_product }}">
          <td class="px-3 py-2 font-mono" data-label="Código">{{ item.code_product }}</td>
          <td class="px-3 py-2 desc-cell" data-label="Descripción">{{ item.description_product }}</td>
          <td class="px-3 py-2" data-label="Unidad">{{ item.unit_description }}</td>
          <td class="px-3 py-2 text-right" data-label="Cant. Orden" data-original="{{ item.amount }}">{{ item.amount }}</td>
          <td class="px-3 py-2 text-right counted-cell" data-label="Cant. Contada" data-counted=""><span class="text-gray-400 italic">Sin conteo</span></td>
          <td class="px-3 py-2 text-right status-cell" data-label="Estado"><span class="inline-block px-2 py-1 rounded bg-gray-200 text-gray-700 text-xs">Pendiente</span></td>
        </tr>
        {% endfor %}
        {% if not items %}
        <tr><td colspan="7" class="px-3 py-4 text-center text-gray-500">Sin detalles para este correlativo.</td></tr>
        {% endif %}
      </tbody>
    </table>
  </div>

  {% endif %}
    <script>
    document.addEventListener('DOMContentLoaded', () => {
      const metaDiv = document.getElementById('check-meta');
      const notFound = metaDiv ? (metaDiv.dataset.notFound === '1') : false;
      const pending = metaDiv ? (metaDiv.dataset.pending === '1') : false;
      if (pending) {
        alert('La TRANSFER existe pero aún está en espera (wait=true). Debe procesarse antes de chequear recepción.');
        try { document.getElementById('correlative').focus(); } catch(e){}
      } else if (notFound) {
        alert('No se encontró una TRANSFER procesada con ese correlativo.');
        try { document.getElementById('correlative').focus(); } catch(e){}
      }

      const rawCorr = metaDiv ? metaDiv.dataset.correlative : '';
      const correlative = rawCorr ? parseInt(rawCorr, 10) : null;
      const searchInput = document.getElementById('product-search');
      const manualInput = document.getElementById('manual-code');
      const countedInput = document.getElementById('counted-qty');
      const applyBtn = document.getElementById('apply-count');
      const finalizeBtn = document.getElementById('finalize-reception');
      const statusMsg = document.getElementById('status-msg');
      const tableBody = document.getElementById('collection-items');
      if (!tableBody) return;

      function normalize(v){ return (v||'').toString().trim().toLowerCase(); }
      function findRowByCode(code){ const q=(code||'').toString().trim().toLowerCase(); const rows=Array.from(tableBody.querySelectorAll('tr[data-code]')); return rows.find(r => (r.dataset.code||'').toLowerCase()===q) || null; }
      function setStatus(msg, kind='info'){ statusMsg.textContent=msg; statusMsg.className='text-sm '+(kind==='error'?'text-red-600':kind==='success'?'text-green-600':'text-gray-700'); }
      function markRow(row, original, counted){ const statusCell=row.querySelector('.status-cell'); const countedCell=row.querySelector('.counted-cell'); if(!statusCell||!countedCell) return; countedCell.dataset.counted=counted; countedCell.innerHTML = `<span>${Number(counted).toFixed(3)}</span>`; const diff = Math.abs(Number(original)-Number(counted)) < 1e-9; if(diff){ statusCell.innerHTML='<span class="inline-block px-2 py-1 rounded bg-green-100 text-green-700 text-xs">Ok</span>'; row.style.display='none'; setStatus('Producto conciliado y ocultado de la lista', 'success'); } else { statusCell.innerHTML='<span class="inline-block px-2 py-1 rounded bg-yellow-200 text-yellow-800 text-xs">Ajustado</span>'; row.classList.add('bg-yellow-50'); } }

      applyBtn && applyBtn.addEventListener('click', async () => {
        let code = normalize(searchInput.value);
        const countedRaw = countedInput.value;
        if (!code){ setStatus('Ingresa un código primero', 'error'); return; }
        let row = findRowByCode(code);
        if (!row){
          try {
            const url = new URL('{{ url_for("api_reception_resolve_code") }}', window.location.origin);
            url.searchParams.set('correlative', correlative ?? '');
            url.searchParams.set('query', code);
            const res = await fetch(url.toString(), { headers: { 'X-Requested-With': 'XMLHttpRequest' }});
            if (res.ok){ const data = await res.json(); if (data && data.ok && data.product_code){ code=String(data.product_code); row=findRowByCode(code); } }
          } catch(e){}
        }
        if (!row){ setStatus('Producto no encontrado en la TRANSFER', 'error'); return; }
        let countedVal = Number(String(countedRaw).replace(',', '.'));
        if (isNaN(countedVal) || countedVal < 0){ setStatus('Cantidad contada inválida', 'error'); return; }
        const original = Number(row.querySelector('[data-original]').dataset.original);
        if (correlative === null){ setStatus('No hay correlativo cargado.', 'error'); return; }
        try {
          // Sólo chequeo: no modificar DB, actualizar UI localmente
          markRow(row, original, countedVal);
          setStatus('Conteo aplicado (no se grabó en DB)', 'success');
          searchInput.value=''; countedInput.value='';
          if (manualInput) { manualInput.value=''; }
          try{ searchInput.focus(); }catch(e){}
          try { reevaluateFinalizeState(); } catch(_){ }
        } catch(e){ setStatus(e.message, 'error'); }
      });

      finalizeBtn && finalizeBtn.addEventListener('click', async () => {
        if (correlative === null){ setStatus('Sin correlativo', 'error'); return; }
        finalizeBtn.disabled = true; setStatus('Validando recepción ...');
        try {
          const rows = Array.from(tableBody.querySelectorAll('tr[data-code]'));
          const counts = {};
          const countedCodes = [];
          rows.forEach(r => {
            const cell = r.querySelector('.counted-cell');
            if (cell && cell.dataset.counted !== ''){ counts[r.dataset.code] = Number(cell.dataset.counted); countedCodes.push(r.dataset.code); }
          });
          const formData = new URLSearchParams();
          formData.set('correlative', correlative);
          formData.set('counted_codes', countedCodes.join(','));
          formData.set('counts', JSON.stringify(counts));
          const res = await fetch('{{ url_for("api_reception_confirm") }}', { method:'POST', headers:{'Content-Type':'application/x-www-form-urlencoded','X-Requested-With':'XMLHttpRequest'}, body: formData.toString() });
          const data = await res.json();
          if (!res.ok || !data.ok) throw new Error(data.error || 'Error en validación de recepción');
          setStatus(data.message || 'Recepción validada', 'success');
          const pdfUrl = '{{ url_for("collection_preview_pdf") }}' + '?correlative=' + data.transfer_correlative + '&operation_type=TRANSFER&wait=false';
          window.open(pdfUrl, '_blank');
        } catch(e){ setStatus(e.message, 'error'); }
        finally { finalizeBtn.disabled = false; }
      });

      // Suprimir teclado virtual en móviles (scanner conectado)
      if (searchInput && /Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) {
        // Reaplicar atributos defensivamente
        searchInput.setAttribute('inputmode','none');
        searchInput.setAttribute('autocomplete','off');
        searchInput.setAttribute('autocorrect','off');
        searchInput.setAttribute('spellcheck','false');
        // Evitar que un tap abra el teclado
        searchInput.addEventListener('touchstart', (e) => {
          e.preventDefault();
          searchInput.focus({ preventScroll: true });
          // Algunos navegadores experimentales
          if (navigator.virtualKeyboard && navigator.virtualKeyboard.hide) {
            try { navigator.virtualKeyboard.hide(); } catch(_){}
          }
        }, { passive: false });
        // En foco, intentar ocultar si abre
        searchInput.addEventListener('focus', () => {
          if (navigator.virtualKeyboard && navigator.virtualKeyboard.hide) {
            try { navigator.virtualKeyboard.hide(); } catch(_){}
          }
        });
      }

      searchInput && searchInput.addEventListener('input', () => {
        const code = normalize(searchInput.value);
        Array.from(tableBody.querySelectorAll('tr')).forEach(tr => tr.classList.remove('ring','ring-indigo-300','collection-highlight'));
        if (!code) return; const row=findRowByCode(code); if (row){ row.classList.add('collection-highlight'); }
      });

      // Sincronizar input manual con buscador (para permitir teclado normal)
      manualInput && manualInput.addEventListener('input', () => {
        if (!manualInput.value) return;
        searchInput.value = manualInput.value;
        searchInput.dispatchEvent(new Event('input'));
      });
      manualInput && manualInput.addEventListener('keydown', async (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          searchInput.value = manualInput.value;
          const code = normalize(manualInput.value);
          if (!code){ setStatus('Ingresa un código primero', 'error'); return; }
          const result = await resolveToRow(code);
          if (!result.row){ setStatus('Producto no encontrado en la TRANSFER', 'error'); return; }
          Array.from(tableBody.querySelectorAll('tr')).forEach(tr => tr.classList.remove('collection-highlight'));
          result.row.classList.add('collection-highlight');
          countedInput.focus(); try{ countedInput.select(); }catch(e){}
        }
      });

      async function resolveToRow(code){ let row=findRowByCode(code); if(!row){ try{ const url=new URL('{{ url_for("api_reception_resolve_code") }}', window.location.origin); url.searchParams.set('correlative', correlative ?? ''); url.searchParams.set('query', code); const res=await fetch(url.toString(), { headers: { 'X-Requested-With': 'XMLHttpRequest' }}); if(res.ok){ const data=await res.json(); if(data && data.ok && data.product_code){ code=String(data.product_code); row=findRowByCode(code); if(row){ searchInput.value=code; } } } }catch(e){} } return { row, code }; }

      searchInput && searchInput.addEventListener('keydown', async (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          const code=normalize(searchInput.value);
          if(!code){ setStatus('Ingresa un código primero', 'error'); return; }
          const result=await resolveToRow(code);
          if(!result.row){ setStatus('Producto no encontrado en la TRANSFER', 'error'); return; }
          Array.from(tableBody.querySelectorAll('tr')).forEach(tr => tr.classList.remove('ring','ring-indigo-300'));
          result.row.classList.add('collection-highlight');
          countedInput.focus(); try{ countedInput.select(); }catch(e){}
        }
      });

      countedInput && countedInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); applyBtn.focus(); } });
      applyBtn && applyBtn.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); applyBtn.click(); } });

      function allRowsCounted(){ const rows=Array.from(tableBody.querySelectorAll('tr[data-code]')); if(rows.length===0) return false; return rows.every(r => { const countedCell=r.querySelector('.counted-cell'); return countedCell && countedCell.dataset.counted !== ''; }); }
      function reevaluateFinalizeState(){ if(!finalizeBtn) return; // Siempre activo para permitir validación parcial
        finalizeBtn.disabled = false; }
      reevaluateFinalizeState();
    });
    </script>
        </div>
 {% endblock %}