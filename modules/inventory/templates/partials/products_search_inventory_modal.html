
<div id="products-modal-overlay" class="fixed inset-0 bg-black/40 z-50 hidden" onclick="closeProductsModal()"></div>

<div id="products-modal-panel" class="fixed inset-0 z-50 flex items-start justify-center p-4 hidden">
	<div class="w-full max-w-4xl bg-white rounded shadow border">
		<div class="flex items-center justify-between p-2 border-b">
			<h3 class="text-sm font-semibold">Buscar productos</h3>
			<button type="button" class="text-xs px-2 py-1" onclick="closeProductsModal()">Cerrar</button>
		</div>
		<div class="p-3 space-y-3">
				<div class="flex gap-2 items-center">
					<input id="products-modal-query" type="text" class="border border-gray-300 rounded px-3 py-2 text-sm w-full focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-teal-500" placeholder="Código o descripción">
					<button id="products-modal-search" class="px-3 py-2 text-sm rounded bg-teal-600 text-white shadow hover:bg-teal-700">Buscar</button>
				</div>

			<div id="products-modal-body" class="overflow-auto border rounded" style="max-height:60vh;">
				<table class="min-w-full text-sm table-fixed border-collapse" role="table">
					<thead class="bg-white border-b sticky top-0 z-10">
						<tr>
							<th class="px-3 py-3 text-left text-xs font-medium text-gray-600">Código</th>
							<th class="px-3 py-3 text-left text-xs font-medium text-gray-600">Descripción</th>
							<th class="px-3 py-3 text-left text-xs font-medium text-gray-600">Unidad</th>
							<th class="px-3 py-3 text-right text-xs font-medium text-gray-600">Stock (Depósito Origen)</th>
						</tr>
					</thead>
					<tbody id="products-modal-tbody" class="divide-y divide-gray-100"></tbody>
				</table>
			</div>

			<div class="flex items-center justify-between">
				<div id="products-modal-status" class="text-xs text-gray-600"></div>
				<div>
					<button id="products-modal-loadmore" class="px-3 py-1 text-sm rounded bg-gray-100 border shadow-sm" style="display:none">Cargar más</button>
				</div>
			</div>
		</div>
	</div>
</div>

<script>
/* products modal script - self contained */
(function(){
	let _offset = 0;
	const _limit = 50;
	let _total = null;
	let _lastQuery = '';
	let _loading = false;
	// items mostrados actualmente y selección por teclado
	let _lastItems = [];
	let _selectedIndex = -1;

	function qs(selector){ return document.querySelector(selector); }

	window.openProductsModal = async function(){
			const ov = qs('#products-modal-overlay');
			const panel = qs('#products-modal-panel');
			if(ov) ov.classList.remove('hidden');
			if(panel) panel.classList.remove('hidden');
			_offset = 0; _total = null;
			// Ejecutar búsqueda y esperar a que termine para asegurar que el input exista
			try{
				await runProductsSearch();
			}catch(e){ /* ignore */ }
			// Forzar foco en el input con varios fallbacks
			const focusInput = () => {
				try{
					const q = qs('#products-modal-query');
					if(q){ q.focus(); if(typeof q.select === 'function') q.select(); }
				}catch(e){/* noop */}
			};
			try{
				requestAnimationFrame(() => requestAnimationFrame(focusInput));
				// also fallback after a short timeout (increased for robustness)
				setTimeout(focusInput, 300);
			}catch(e){
				setTimeout(focusInput, 120);
			}
		}

	window.closeProductsModal = function(){
		const ov = qs('#products-modal-overlay');
		const panel = qs('#products-modal-panel');
		if(ov) ov.classList.add('hidden');
		if(panel) panel.classList.add('hidden');
	}

	async function runProductsSearch(replace=true){
		const q = qs('#products-modal-query').value.trim();
		_lastQuery = q;
		_offset = replace ? 0 : _offset;
		qs('#products-modal-status').textContent = 'Cargando...';
		_loading = true;
		try{
			const url = new URL(window.location.origin + '/inventory/api/products/search');
			url.searchParams.set('q', q);
			url.searchParams.set('limit', _limit);
			url.searchParams.set('offset', _offset);
			const res = await fetch(url.toString());
			const data = await res.json();
			if(!data.ok){ qs('#products-modal-status').textContent = data.error || 'Error en búsqueda'; return; }
			const items = data.items || [];
			if (data.total !== undefined) _total = data.total;
			renderRows(items, replace);
			const shown = document.querySelectorAll('#products-modal-tbody tr').length;
			if(_total === null){
				// unknown total, show load more if items length == limit
				qs('#products-modal-loadmore').style.display = (items.length === _limit) ? 'inline-block' : 'none';
			} else {
				qs('#products-modal-loadmore').style.display = (shown < _total) ? 'inline-block' : 'none';
			}
			qs('#products-modal-status').textContent = `Mostrando ${shown}${_total? ' de '+_total: ''}`;
		}catch(e){
			console.error(e);
			qs('#products-modal-status').textContent = 'Error en la búsqueda';
		}finally{
			_loading = false;
		}
	}

	function renderRows(items, replace){
		const tbody = qs('#products-modal-tbody');
		if(replace){ tbody.innerHTML = ''; _lastItems = []; _selectedIndex = -1; }
		const startIndex = _lastItems.length;
				items.forEach(function(it, idx){
			const rowIndex = startIndex + idx;
			_lastItems.push(it);
			const tr = document.createElement('tr');
			tr.className = 'cursor-pointer hover:bg-gray-50';
			tr.tabIndex = 0;
			tr.dataset.idx = String(rowIndex);
					tr.innerHTML = `
						<td class="px-2 py-1">${escapeHtml(it.code || '')}</td>
						<td class="px-2 py-1">${escapeHtml(it.description || '')}</td>
						<td class="px-2 py-1">${escapeHtml(it.unit_description || '')}</td>
						<td class="px-2 py-1 text-right"><span class="product-origin-stock" data-code="${escapeHtml(it.code || '')}">...</span></td>
					`;
			tr.addEventListener('click', function(){ selectProduct(it); });
			tr.addEventListener('mouseenter', function(){ setSelection(rowIndex, {focus: false}); });
			tbody.appendChild(tr);
					// Asíncronamente obtener stock del depósito origen y actualizar la celda
					try{ fetchOriginStockForRow(tr, it.code); }catch(e){ /* noop */ }
		});
		// Ensure a selection exists (first row) when new results arrive
		if(_lastItems.length > 0 && _selectedIndex === -1){
			// If the search input currently has focus (user is typing), do NOT steal focus
			const inputEl = qs('#products-modal-query');
			if(!(inputEl && document.activeElement === inputEl)){
				setSelection(0);
			} else {
				// leave selection unset so typing isn't interrupted; ArrowDown will set it
				_selectedIndex = -1;
			}
		}
	}

	function clearSelection(){
		const rows = document.querySelectorAll('#products-modal-tbody tr');
		rows.forEach(r => r.classList.remove('bg-teal-100'));
		_selectedIndex = -1;
	}

	function setSelection(idx, opts){
		// opts: { focus: true|false }
		opts = opts || {};
		const shouldFocus = (opts.focus === undefined) ? true : !!opts.focus;
		const rows = document.querySelectorAll('#products-modal-tbody tr');
		if(rows.length === 0) return;
		if(idx < 0) idx = 0;
		if(idx >= _lastItems.length) idx = _lastItems.length - 1;
		// remove previous
		rows.forEach(r => r.classList.remove('bg-teal-100'));
		const row = Array.from(rows).find(r => Number(r.dataset.idx) === idx);
		if(row){
			row.classList.add('bg-teal-100');
			if(shouldFocus){
				try{ row.focus(); }catch(e){/* noop */}
			}
		}
		_selectedIndex = idx;
	}

	function moveSelection(delta){
		if(_lastItems.length === 0) return;
		let next = (_selectedIndex === -1) ? 0 : _selectedIndex + delta;
		if(next < 0) next = 0;
		if(next >= _lastItems.length) next = _lastItems.length - 1;
		setSelection(next);
	}

	function confirmSelectionAndMaybeAdd(){
		// NOTE: Historically this function auto-clicked the 'Agregar' button after
		// selecting a product. That caused products to be added immediately when
		// the user pressed Enter on a modal selection. Now it only selects the
		// product (populates the details UI) and closes the modal. The user must
		// explicitly press 'Agregar' to add the product to the order.
		if(_selectedIndex >= 0 && _selectedIndex < _lastItems.length){
			const prod = _lastItems[_selectedIndex];
			// select product (close modal and populate UI)
			selectProduct(prod);
		}
	}

	function selectProduct(product){
		if(window.onInventoryProductSelected && typeof window.onInventoryProductSelected === 'function'){
			window.onInventoryProductSelected(product);
		}

		// Limpiar el input de búsqueda del modal después de seleccionar
		try{
			const qEl = qs('#products-modal-query');
			if(qEl) qEl.value = '';
		}catch(e){ /* noop */ }

		closeProductsModal();
	}

	function escapeHtml(s){ if(s===null||s===undefined) return ''; return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }

	// Debounce helper to avoid ejecutar muchas búsquedas mientras el usuario escribe
	function debounce(fn, wait){
		let t = null;
		return function(...args){
			if(t) clearTimeout(t);
			t = setTimeout(()=> fn.apply(this, args), wait);
		};
	}

	// Obtener el código del depósito origen desde el formulario principal (si existe)
	function getOriginStoreCode(){
		try{
			const el = document.querySelector('input[name="stock_store_origin"]');
			if(el) return (el.value || '').trim();
		}catch(e){/* noop */}
		return '';
	}

	function formatStockValue(v){
		if(v === null || v === undefined || v === '') return 'N/D';
		const n = Number(v);
		if(Number.isNaN(n)) return 'N/D';
		if(Math.abs(n - Math.round(n)) < 1e-9) return String(Math.round(n));
		return Number(n.toFixed(3)).toString();
	}

	// Consulta el endpoint de stock por producto y actualiza la celda correspondiente
	async function fetchOriginStockForRow(tr, productCode){
		try{
			if(!productCode) return;
			const origin = getOriginStoreCode();
			if(!origin) {
				// Si no hay origen definido, intentar usar valores provistos en la fila (it.total_stock fallback)
				const span = tr.querySelector('.product-origin-stock');
				if(span){ span.textContent = formatStockValue(span.dataset.fallback || ''); }
				return;
			}
			const url = new URL(window.location.origin + '{{ url_for("inventory.api_products_stocks_by_product") }}');
			url.searchParams.set('code', productCode || '');
			const res = await fetch(url.toString());
			if(!res.ok) return;
			const data = await res.json();
			if(!data || !data.ok || !Array.isArray(data.stocks)) return;
			// buscar el stock del depósito origen
			let found = null;
			for(const s of data.stocks){
				try{
					if(s && (s.is_origin || String(s.store_code) === String(origin))){ found = s; break; }
				}catch(e){/* ignore */}
			}
			const span = tr.querySelector('.product-origin-stock');
			if(!span) return;
			if(found && (found.stock !== null && found.stock !== undefined)){
				span.textContent = formatStockValue(found.stock);
				span.dataset.mainStock = String(found.stock);
			} else {
				// Si no encontró en depósitos, usar total_stock si viene en el item original
				const item = _lastItems[Number(tr.dataset.idx)];
				const fallback = item && (item.total_stock ?? item.stock) ? (item.total_stock ?? item.stock) : '';
				span.textContent = formatStockValue(fallback);
				if(fallback !== '') span.dataset.fallback = String(fallback);
			}
		}catch(e){ console.error('fetchOriginStockForRow error', e); }
	}

	qs('#products-modal-search').addEventListener('click', function(){ runProductsSearch(true); });
	qs('#products-modal-query').addEventListener('keydown', function(e){
		if(e.key === 'Enter'){
			e.preventDefault();
			e.stopPropagation();
			// If there's a selection, confirm it; otherwise perform search
			if(_selectedIndex >= 0){ confirmSelectionAndMaybeAdd(); }
			else { runProductsSearch(true); }
		} else if(e.key === 'ArrowDown'){
			e.preventDefault(); e.stopPropagation(); moveSelection(1);
		} else if(e.key === 'ArrowUp'){
			e.preventDefault(); e.stopPropagation(); moveSelection(-1);
		}
	});
	// Búsqueda en tiempo real mientras se escribe (debounced)
	const liveSearch = debounce(function(){ runProductsSearch(true); }, 300);
	qs('#products-modal-query').addEventListener('input', function(e){ liveSearch(); });

	qs('#products-modal-loadmore').addEventListener('click', async function(){ if(_loading) return; _offset += _limit; await runProductsSearch(false); });

	// Scroll-infinite: al hacer scroll al fondo del contenedor cargar más
	const bodyEl = qs('#products-modal-body');
	if(bodyEl){
		bodyEl.addEventListener('scroll', async function(){
			try{
				if(_loading) return;
				const nearBottom = (bodyEl.scrollTop + bodyEl.clientHeight) >= (bodyEl.scrollHeight - 60);
				if(nearBottom){
					const shown = document.querySelectorAll('#products-modal-tbody tr').length;
					if((_total === null && shown % _limit === 0) || (typeof _total === 'number' && shown < _total)){
						_offset += _limit;
						await runProductsSearch(false);
					}
				}
			}catch(e){ console.error('scroll load more error', e); }
		});
	}

	// close on ESC and allow arrow navigation when modal is open
	document.addEventListener('keydown', function(e){
		const panel = qs('#products-modal-panel');
		const isOpen = panel && !panel.classList.contains('hidden');
		if(e.key === 'Escape' && isOpen){ closeProductsModal(); }
		if(!isOpen) return;
		if(e.key === 'ArrowDown'){ e.preventDefault(); moveSelection(1); }
		if(e.key === 'ArrowUp'){ e.preventDefault(); moveSelection(-1); }
		if(e.key === 'Enter'){
			// Only handle enter if focus is inside modal (to avoid interfering elsewhere)
			const active = document.activeElement;
			if(panel.contains(active)){
				e.preventDefault();
				confirmSelectionAndMaybeAdd();
			}
		}
	});
})();
</script>
